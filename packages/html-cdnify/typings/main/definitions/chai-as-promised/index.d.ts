// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-chai/e8db615cea6be222a9547bead73ec66b82691108/lib/Assertion.d.ts
declare module '~chai-as-promised~chai/lib/Assertion' {
export interface AssertionStatic {
  (target: any, message?: string): Assertion;
}

export interface Assertion extends LanguageChains, NumericComparison, TypeComparison {
  not: Assertion;
  deep: Deep;
  any: KeyFilter;
  all: KeyFilter;
  a: TypeComparison;
  an: TypeComparison;
  include: Include;
  includes: Include;
  contain: Include;
  contains: Include;
  ok: Assertion;
  true: Assertion;
  false: Assertion;
  null: Assertion;
  undefined: Assertion;
  NaN: Assertion;
  exist: Assertion;
  empty: Assertion;
  arguments: Assertion;
  Arguments: Assertion;
  equal: Equal;
  equals: Equal;
  eq: Equal;
  eql: Equal;
  eqls: Equal;
  property: Property;
  ownProperty: OwnProperty;
  haveOwnProperty: OwnProperty;
  ownPropertyDescriptor: OwnPropertyDescriptor;
  haveOwnPropertyDescriptor: OwnPropertyDescriptor;
  length: Length;
  lengthOf: Length;
  match: Match;
  matches: Match;
  string(string: string, message?: string): Assertion;
  keys: Keys;
  key(string: string): Assertion;
  throw: Throw;
  throws: Throw;
  Throw: Throw;
  respondTo: RespondTo;
  respondsTo: RespondTo;
  itself: Assertion;
  satisfy: Satisfy;
  satisfies: Satisfy;
  closeTo: CloseTo;
  approximately: CloseTo;
  members: Members;
  increase: PropertyChange;
  increases: PropertyChange;
  decrease: PropertyChange;
  decreases: PropertyChange;
  change: PropertyChange;
  changes: PropertyChange;
  extensible: Assertion;
  sealed: Assertion;
  frozen: Assertion;
  oneOf(list: any[], message?: string): Assertion;
}

export interface LanguageChains {
  to: Assertion;
  be: Assertion;
  been: Assertion;
  is: Assertion;
  that: Assertion;
  which: Assertion;
  and: Assertion;
  has: Assertion;
  have: Assertion;
  with: Assertion;
  at: Assertion;
  of: Assertion;
  same: Assertion;
}

export interface NumericComparison {
  above: NumberComparer;
  gt: NumberComparer;
  greaterThan: NumberComparer;
  least: NumberComparer;
  gte: NumberComparer;
  below: NumberComparer;
  lt: NumberComparer;
  lessThan: NumberComparer;
  most: NumberComparer;
  lte: NumberComparer;
  within(start: number, finish: number, message?: string): Assertion;
}

export interface NumberComparer {
  (value: number, message?: string): Assertion;
}

export interface TypeComparison {
  (type: string, message?: string): Assertion;
  instanceof: InstanceOf;
  instanceOf: InstanceOf;
}

export interface InstanceOf {
  (constructor: Object, message?: string): Assertion;
}

export interface CloseTo {
  (expected: number, delta: number, message?: string): Assertion;
}

export interface Deep {
  equal: Equal;
  include: Include;
  property: Property;
  members: Members;
}

export interface KeyFilter {
  keys: Keys;
}

export interface Equal {
  (value: any, message?: string): Assertion;
}

export interface Property {
  (name: string, value?: any, message?: string): Assertion;
}

export interface OwnProperty {
  (name: string, message?: string): Assertion;
}

export interface OwnPropertyDescriptor {
  (name: string, descriptor: PropertyDescriptor, message?: string): Assertion;
  (name: string, message?: string): Assertion;
}

export interface Length extends LanguageChains, NumericComparison {
  (length: number, message?: string): Assertion;
}

export interface Include {
  (value: Object, message?: string): Assertion;
  (value: string, message?: string): Assertion;
  (value: number, message?: string): Assertion;
  keys: Keys;
  members: Members;
  any: KeyFilter;
  all: KeyFilter;
}

export interface Match {
  (regexp: RegExp | string, message?: string): Assertion;
}

export interface Keys {
  (...keys: string[]): Assertion;
  (keys: any[]): Assertion;
  (keys: Object): Assertion;
}

export interface Throw {
  (): Assertion;
  (expected: string, message?: string): Assertion;
  (expected: RegExp, message?: string): Assertion;
  (constructor: Error, expected?: string, message?: string): Assertion;
  (constructor: Error, expected?: RegExp, message?: string): Assertion;
  (constructor: Function, expected?: string, message?: string): Assertion;
  (constructor: Function, expected?: RegExp, message?: string): Assertion;
}

export interface RespondTo {
  (method: string, message?: string): Assertion;
}

export interface Satisfy {
  (matcher: Function, message?: string): Assertion;
}

export interface Members {
  (set: any[], message?: string): Assertion;
}

export interface PropertyChange {
  (object: Object, prop: string, msg?: string): Assertion;
}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/typed-typings/npm-chai/e8db615cea6be222a9547bead73ec66b82691108/lib/Assert.d.ts
declare module '~chai-as-promised~chai/lib/Assert' {
export interface AssertStatic extends Assert {
}

export interface Assert {
    /**
     * @param expression Expression to test for truthiness.
     * @param message Message to display on error.
     */
    (expression: any, message?: string): void;

    fail(actual?: any, expected?: any, msg?: string, operator?: string): void;

    ok(val: any, msg?: string): void;
    isOk(val: any, msg?: string): void;
    notOk(val: any, msg?: string): void;
    isNotOk(val: any, msg?: string): void;

    equal(act: any, exp: any, msg?: string): void;
    notEqual(act: any, exp: any, msg?: string): void;

    strictEqual(act: any, exp: any, msg?: string): void;
    notStrictEqual(act: any, exp: any, msg?: string): void;

    deepEqual(act: any, exp: any, msg?: string): void;
    notDeepEqual(act: any, exp: any, msg?: string): void;

    isTrue(val: any, msg?: string): void;
    isFalse(val: any, msg?: string): void;

    isNotTrue(val: any, msg?: string): void;
    isNotFalse(val: any, msg?: string): void;

    isNull(val: any, msg?: string): void;
    isNotNull(val: any, msg?: string): void;

    isUndefined(val: any, msg?: string): void;
    isDefined(val: any, msg?: string): void;

    isNaN(val: any, msg?: string): void;
    isNotNaN(val: any, msg?: string): void;

    isAbove(val: number, abv: number, msg?: string): void;
    isBelow(val: number, blw: number, msg?: string): void;

    isAtLeast(val: number, atlst: number, msg?: string): void;
    isAtMost(val: number, atmst: number, msg?: string): void;

    isFunction(val: any, msg?: string): void;
    isNotFunction(val: any, msg?: string): void;

    isObject(val: any, msg?: string): void;
    isNotObject(val: any, msg?: string): void;

    isArray(val: any, msg?: string): void;
    isNotArray(val: any, msg?: string): void;

    isString(val: any, msg?: string): void;
    isNotString(val: any, msg?: string): void;

    isNumber(val: any, msg?: string): void;
    isNotNumber(val: any, msg?: string): void;

    isBoolean(val: any, msg?: string): void;
    isNotBoolean(val: any, msg?: string): void;

    typeOf(val: any, type: string, msg?: string): void;
    notTypeOf(val: any, type: string, msg?: string): void;

    instanceOf(val: any, type: Function, msg?: string): void;
    notInstanceOf(val: any, type: Function, msg?: string): void;

    include(exp: string, inc: any, msg?: string): void;
    include(exp: any[], inc: any, msg?: string): void;

    notInclude(exp: string, inc: any, msg?: string): void;
    notInclude(exp: any[], inc: any, msg?: string): void;

    match(exp: any, re: RegExp, msg?: string): void;
    notMatch(exp: any, re: RegExp, msg?: string): void;

    property(obj: Object, prop: string, msg?: string): void;
    notProperty(obj: Object, prop: string, msg?: string): void;
    deepProperty(obj: Object, prop: string, msg?: string): void;
    notDeepProperty(obj: Object, prop: string, msg?: string): void;

    propertyVal(obj: Object, prop: string, val: any, msg?: string): void;
    propertyNotVal(obj: Object, prop: string, val: any, msg?: string): void;

    deepPropertyVal(obj: Object, prop: string, val: any, msg?: string): void;
    deepPropertyNotVal(obj: Object, prop: string, val: any, msg?: string): void;

    lengthOf(exp: any, len: number, msg?: string): void;
    //alias frenzy
    throw(fn: Function, msg?: string): void;
    throw(fn: Function, regExp: RegExp): void;
    throw(fn: Function, errType: Function, msg?: string): void;
    throw(fn: Function, errType: Function, regExp: RegExp): void;

    throws(fn: Function, msg?: string): void;
    throws(fn: Function, regExp: RegExp): void;
    throws(fn: Function, errType: Function, msg?: string): void;
    throws(fn: Function, errType: Function, regExp: RegExp): void;

    Throw(fn: Function, msg?: string): void;
    Throw(fn: Function, regExp: RegExp): void;
    Throw(fn: Function, errType: Function, msg?: string): void;
    Throw(fn: Function, errType: Function, regExp: RegExp): void;

    doesNotThrow(fn: Function, msg?: string): void;
    doesNotThrow(fn: Function, regExp: RegExp): void;
    doesNotThrow(fn: Function, errType: Function, msg?: string): void;
    doesNotThrow(fn: Function, errType: Function, regExp: RegExp): void;

    operator(val: any, operator: string, val2: any, msg?: string): void;
    closeTo(act: number, exp: number, delta: number, msg?: string): void;
    approximately(act: number, exp: number, delta: number, msg?: string): void;

    sameMembers(set1: any[], set2: any[], msg?: string): void;
    sameDeepMembers(set1: any[], set2: any[], msg?: string): void;
    includeMembers(superset: any[], subset: any[], msg?: string): void;

    ifError(val: any, msg?: string): void;

    isExtensible(obj: {}, msg?: string): void;
    extensible(obj: {}, msg?: string): void;
    isNotExtensible(obj: {}, msg?: string): void;
    notExtensible(obj: {}, msg?: string): void;

    isSealed(obj: {}, msg?: string): void;
    sealed(obj: {}, msg?: string): void;
    isNotSealed(obj: {}, msg?: string): void;
    notSealed(obj: {}, msg?: string): void;

    isFrozen(obj: Object, msg?: string): void;
    frozen(obj: Object, msg?: string): void;
    isNotFrozen(obj: Object, msg?: string): void;
    notFrozen(obj: Object, msg?: string): void;

    oneOf(inList: any, list: any[], msg?: string): void;
  }
}

// Generated by typings
// Source: https://raw.githubusercontent.com/asvetliakov/typings-chai-as-promised/06e0c2fef27801c64a2a03be52bc9235b7e8660d/index.d.ts
declare module '~chai-as-promised/index' {
import {LanguageChains} from '~chai-as-promised~chai/lib/Assertion';
import {NumericComparison} from '~chai-as-promised~chai/lib/Assertion';
import {TypeComparison} from '~chai-as-promised~chai/lib/Assertion';
import { Assert } from '~chai-as-promised~chai/lib/Assert';
import '~chai/lib/Assertion';
import '~chai/lib/Assert';

namespace ChaiPromised {

    // For BDD API

    // Eventually does not have .then(), but PromisedAssertion have.
    interface Eventually extends PromisedLanguageChains, PromisedNumericComparison, PromisedTypeComparison {
        // From chai-as-promised
        become(expected: Promise<any>): PromisedAssertion;
        fulfilled: PromisedAssertion;
        rejected: PromisedAssertion;
        rejectedWith(expected: any): PromisedAssertion;
        notify(fn: Function): PromisedAssertion;

        // From chai
        not: PromisedAssertion;
        deep: PromisedDeep;
        a: PromisedTypeComparison;
        an: PromisedTypeComparison;
        include: PromisedInclude;
        contain: PromisedInclude;
        ok: PromisedAssertion;
        true: PromisedAssertion;
        false: PromisedAssertion;
        null: PromisedAssertion;
        undefined: PromisedAssertion;
        exist: PromisedAssertion;
        empty: PromisedAssertion;
        arguments: PromisedAssertion;
        Arguments: PromisedAssertion;
        equal: PromisedEqual;
        equals: PromisedEqual;
        eq: PromisedEqual;
        eql: PromisedEqual;
        eqls: PromisedEqual;
        property: PromisedProperty;
        ownProperty: PromisedOwnProperty;
        haveOwnProperty: PromisedOwnProperty;
        length: PromisedLength;
        lengthOf: PromisedLength;
        match(regexp: RegExp|string, message?: string): PromisedAssertion;
        string(string: string, message?: string): PromisedAssertion;
        keys: PromisedKeys;
        key(string: string): PromisedAssertion;
        throw: PromisedThrow;
        throws: PromisedThrow;
        Throw: PromisedThrow;
        respondTo(method: string, message?: string): PromisedAssertion;
        itself: PromisedAssertion;
        satisfy(matcher: Function, message?: string): PromisedAssertion;
        closeTo(expected: number, delta: number, message?: string): PromisedAssertion;
        members: PromisedMembers;
    }

    interface PromisedAssertion extends Eventually, Promise<any> {
    }

    interface PromisedLanguageChains {
        eventually: Eventually;

        // From chai
        to: PromisedAssertion;
        be: PromisedAssertion;
        been: PromisedAssertion;
        is: PromisedAssertion;
        that: PromisedAssertion;
        which: PromisedAssertion;
        and: PromisedAssertion;
        has: PromisedAssertion;
        have: PromisedAssertion;
        with: PromisedAssertion;
        at: PromisedAssertion;
        of: PromisedAssertion;
        same: PromisedAssertion;
    }

    interface PromisedNumericComparison {
        above: PromisedNumberComparer;
        gt: PromisedNumberComparer;
        greaterThan: PromisedNumberComparer;
        least: PromisedNumberComparer;
        gte: PromisedNumberComparer;
        below: PromisedNumberComparer;
        lt: PromisedNumberComparer;
        lessThan: PromisedNumberComparer;
        most: PromisedNumberComparer;
        lte: PromisedNumberComparer;
        within(start: number, finish: number, message?: string): PromisedAssertion;
    }

    interface PromisedNumberComparer {
        (value: number, message?: string): PromisedAssertion;
    }

    interface PromisedTypeComparison {
        (type: string, message?: string): PromisedAssertion;
        instanceof: PromisedInstanceOf;
        instanceOf: PromisedInstanceOf;
    }

    interface PromisedInstanceOf {
        (constructor: Object, message?: string): PromisedAssertion;
    }

    interface PromisedDeep {
        equal: PromisedEqual;
        include: PromisedInclude;
        property: PromisedProperty;
    }

    interface PromisedEqual {
        (value: any, message?: string): PromisedAssertion;
    }

    interface PromisedProperty {
        (name: string, value?: any, message?: string): PromisedAssertion;
    }

    interface PromisedOwnProperty {
        (name: string, message?: string): PromisedAssertion;
    }

    interface PromisedLength extends PromisedLanguageChains, PromisedNumericComparison {
        (length: number, message?: string): PromisedAssertion;
    }

    interface PromisedInclude {
        (value: Object, message?: string): PromisedAssertion;
        (value: string, message?: string): PromisedAssertion;
        (value: number, message?: string): PromisedAssertion;
        keys: PromisedKeys;
        members: PromisedMembers;
    }

    interface PromisedKeys {
        (...keys: string[]): PromisedAssertion;
        (keys: any[]): PromisedAssertion;
    }

    interface PromisedThrow {
        (): PromisedAssertion;
        (expected: string, message?: string): PromisedAssertion;
        (expected: RegExp, message?: string): PromisedAssertion;
        (constructor: Error, expected?: string, message?: string): PromisedAssertion;
        (constructor: Error, expected?: RegExp, message?: string): PromisedAssertion;
        (constructor: Function, expected?: string, message?: string): PromisedAssertion;
        (constructor: Function, expected?: RegExp, message?: string): PromisedAssertion;
    }

    interface PromisedMembers {
        (set: any[], message?: string): PromisedAssertion;
    }

    // For Assert API

    export interface PromisedAssert {
        fail(actual?: any, expected?: any, msg?: string, operator?: string): Promise<void>;

        ok(val: any, msg?: string): Promise<void>;
        notOk(val: any, msg?: string): Promise<void>;

        equal(act: any, exp: any, msg?: string): Promise<void>;
        notEqual(act: any, exp: any, msg?: string): Promise<void>;

        strictEqual(act: any, exp: any, msg?: string): Promise<void>;
        notStrictEqual(act: any, exp: any, msg?: string): Promise<void>;

        deepEqual(act: any, exp: any, msg?: string): Promise<void>;
        notDeepEqual(act: any, exp: any, msg?: string): Promise<void>;

        isTrue(val: any, msg?: string): Promise<void>;
        isFalse(val: any, msg?: string): Promise<void>;

        isNull(val: any, msg?: string): Promise<void>;
        isNotNull(val: any, msg?: string): Promise<void>;

        isUndefined(val: any, msg?: string): Promise<void>;
        isDefined(val: any, msg?: string): Promise<void>;

        isFunction(val: any, msg?: string): Promise<void>;
        isNotFunction(val: any, msg?: string): Promise<void>;

        isObject(val: any, msg?: string): Promise<void>;
        isNotObject(val: any, msg?: string): Promise<void>;

        isArray(val: any, msg?: string): Promise<void>;
        isNotArray(val: any, msg?: string): Promise<void>;

        isString(val: any, msg?: string): Promise<void>;
        isNotString(val: any, msg?: string): Promise<void>;

        isNumber(val: any, msg?: string): Promise<void>;
        isNotNumber(val: any, msg?: string): Promise<void>;

        isBoolean(val: any, msg?: string): Promise<void>;
        isNotBoolean(val: any, msg?: string): Promise<void>;

        typeOf(val: any, type: string, msg?: string): Promise<void>;
        notTypeOf(val: any, type: string, msg?: string): Promise<void>;

        instanceOf(val: any, type: Function, msg?: string): Promise<void>;
        notInstanceOf(val: any, type: Function, msg?: string): Promise<void>;

        include(exp: string, inc: any, msg?: string): Promise<void>;
        include(exp: any[], inc: any, msg?: string): Promise<void>;

        notInclude(exp: string, inc: any, msg?: string): Promise<void>;
        notInclude(exp: any[], inc: any, msg?: string): Promise<void>;

        match(exp: any, re: RegExp, msg?: string): Promise<void>;
        notMatch(exp: any, re: RegExp, msg?: string): Promise<void>;

        property(obj: Object, prop: string, msg?: string): Promise<void>;
        notProperty(obj: Object, prop: string, msg?: string): Promise<void>;
        deepProperty(obj: Object, prop: string, msg?: string): Promise<void>;
        notDeepProperty(obj: Object, prop: string, msg?: string): Promise<void>;

        propertyVal(obj: Object, prop: string, val: any, msg?: string): Promise<void>;
        propertyNotVal(obj: Object, prop: string, val: any, msg?: string): Promise<void>;

        deepPropertyVal(obj: Object, prop: string, val: any, msg?: string): Promise<void>;
        deepPropertyNotVal(obj: Object, prop: string, val: any, msg?: string): Promise<void>;

        lengthOf(exp: any, len: number, msg?: string): Promise<void>;
        //alias frenzy
        throw(fn: Function, msg?: string): Promise<void>;
        throw(fn: Function, regExp: RegExp): Promise<void>;
        throw(fn: Function, errType: Function, msg?: string): Promise<void>;
        throw(fn: Function, errType: Function, regExp: RegExp): Promise<void>;

        throws(fn: Function, msg?: string): Promise<void>;
        throws(fn: Function, regExp: RegExp): Promise<void>;
        throws(fn: Function, errType: Function, msg?: string): Promise<void>;
        throws(fn: Function, errType: Function, regExp: RegExp): Promise<void>;

        Throw(fn: Function, msg?: string): Promise<void>;
        Throw(fn: Function, regExp: RegExp): Promise<void>;
        Throw(fn: Function, errType: Function, msg?: string): Promise<void>;
        Throw(fn: Function, errType: Function, regExp: RegExp): Promise<void>;

        doesNotThrow(fn: Function, msg?: string): Promise<void>;
        doesNotThrow(fn: Function, regExp: RegExp): Promise<void>;
        doesNotThrow(fn: Function, errType: Function, msg?: string): Promise<void>;
        doesNotThrow(fn: Function, errType: Function, regExp: RegExp): Promise<void>;

        operator(val: any, operator: string, val2: any, msg?: string): Promise<void>;
        closeTo(act: number, exp: number, delta: number, msg?: string): Promise<void>;

        sameMembers(set1: any[], set2: any[], msg?: string): Promise<void>;
        includeMembers(set1: any[], set2: any[], msg?: string): Promise<void>;

        ifError(val: any, msg?: string): Promise<void>;
    }
}

module '~chai/lib/Assertion' {
    interface Assertion {
        eventually: ChaiPromised.PromisedAssertion;
        become(expected: any): ChaiPromised.PromisedAssertion;
        fulfilled: ChaiPromised.PromisedAssertion;
        rejected: ChaiPromised.PromisedAssertion;
        rejectedWith(expected: any, message?: string): ChaiPromised.PromisedAssertion;
        notify(fn: Function): ChaiPromised.PromisedAssertion;
    }
}

module '~chai/lib/Assert' {
    interface Assert {
        eventually: ChaiPromised.PromisedAssert;
        isFulfilled(promise: Promise<any>, message?: string): Promise<void>;
        becomes(promise: Promise<any>, expected: any, message?: string): Promise<void>;
        doesNotBecome(promise: Promise<any>, expected: any, message?: string): Promise<void>;
        isRejected(promise: Promise<any>, message?: string): Promise<void>;
        isRejected(promise: Promise<any>, expected: any, message?: string): Promise<void>;
        isRejected(promise: Promise<any>, match: RegExp, message?: string): Promise<void>;
        notify(fn: Function): Promise<void>;
    }
}


function chaiAsPromised(chai: any, utils: any): void;
namespace chaiAsPromised {}
export = chaiAsPromised;
}
declare module 'chai-as-promised/index' {
import main = require('~chai-as-promised/index');
export = main;
}
declare module 'chai-as-promised' {
import main = require('~chai-as-promised/index');
export = main;
}
